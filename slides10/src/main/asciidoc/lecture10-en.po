#. extracted from ./slides10/src/main/asciidoc/lecture.adoc
msgid ""
msgstr ""
"Project-Id-Version: slides 10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-12-15 11:39+0300\n"
"PO-Revision-Date: 2021-12-15 11:39+0300\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Translate Toolkit 2.2.5\n"
"Language: en_UK\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: slides10/src/main/asciidoc/lecture.adoc:25
msgid ""
"= Core Java: Курс лекций. Лекция 10\n"
"Иван Пономарёв, КУРС/МФТИ\n"
":revealjs_theme: black\n"
":revealjs_customtheme: white_course.css\n"
":revealjs_slideNumber:\n"
":revealjs_history:\n"
":revealjs_progress:\n"
":encoding: UTF-8\n"
":lang: ru\n"
"include::_doc_general_attributes.adoc[]\n"
":doctype: article\n"
":toclevels: 3\n"
":imagesdir: images\n"
":source-highlighter: highlightjs\n"
":highlightjsdir: highlight\n"
":icons: font\n"
":iconfont-remote!:\n"
":iconfont-name: font-awesome-4.7.0/css/font-awesome\n"
":revealjs_mouseWheel: true\n"
":revealjs_center: false\n"
":revealjs_transition: none\n"
":revealjs_width: 1600\n"
":revealjs_height: 900\n"
":stem: latexmath"
msgstr ""
"= Core Java: Курс лекций. Лекция 10\n"
"Иван Пономарёв, КУРС/МФТИ\n"
":revealjs_theme: black\n"
":revealjs_customtheme: white_course.css\n"
":revealjs_slideNumber:\n"
":revealjs_history:\n"
":revealjs_progress:\n"
":encoding: UTF-8\n"
":lang: ru\n"
"include::_doc_general_attributes.adoc[]\n"
":doctype: article\n"
":toclevels: 3\n"
":imagesdir: images\n"
":source-highlighter: highlightjs\n"
":highlightjsdir: highlight\n"
":icons: font\n"
":iconfont-remote!:\n"
":iconfont-name: font-awesome-4.7.0/css/font-awesome\n"
":revealjs_mouseWheel: true\n"
":revealjs_center: false\n"
":revealjs_transition: none\n"
":revealjs_width: 1600\n"
":revealjs_height: 900\n"
":stem: latexmath"

#: slides10/src/main/asciidoc/lecture.adoc:29
msgid ""
"//== Часть 1. Введение\n"
":!figure-caption:"
msgstr ""
"//== Часть 1. Введение\n"
":!figure-caption:"

#: slides10/src/main/asciidoc/lecture.adoc:31
msgid "ponomarev@corchestra.ru"
msgstr "ponomarev@corchestra.ru"

#: slides10/src/main/asciidoc/lecture.adoc:33
msgid "icon:twitter[size=lg] @inponomarev"
msgstr "icon:twitter[size=lg] @inponomarev"

#: slides10/src/main/asciidoc/lecture.adoc:35
msgid "== Concurrency -- конкурентное выполнение"
msgstr "== Concurrency -- конкурентное выполнение"

#: slides10/src/main/asciidoc/lecture.adoc:38
msgid ""
"* Одна программа -- много одновременно выполняющихся тредов (threads)\n"
"* Зачем нам вообще Concurrency?"
msgstr ""
"* Одна программа -- много одновременно выполняющихся тредов (threads)\n"
"* Зачем нам вообще Concurrency?"

#: slides10/src/main/asciidoc/lecture.adoc:41
msgid ""
"[.fragment]\n"
"-- Для перформанса, чтобы побыстрее!"
msgstr ""
"[.fragment]\n"
"-- Для перформанса, чтобы побыстрее!"

#: slides10/src/main/asciidoc/lecture.adoc:43
msgid "== Где мы можем получить выгоду от concurrency?"
msgstr "== Где мы можем получить выгоду от concurrency?"

#: slides10/src/main/asciidoc/lecture.adoc:48
msgid ""
"* Много CPU-ядер, вычислительная задача хорошо разделяется на подзадачи.\n"
"* Подзадачи блокируются на вводе/выводе, можно параллельно ждать других или "
"делать что-то полезное.\n"
"* Нужно быстро отреагировать на запрос, а потом дать детальный ответ "
"(пользовательский интерфейс).\n"
"* Многопользовательский сервис (каждый запрос в своём треде)."
msgstr ""
"* Много CPU-ядер, вычислительная задача хорошо разделяется на подзадачи.\n"
"* Подзадачи блокируются на вводе/выводе, можно параллельно ждать других или "
"делать что-то полезное.\n"
"* Нужно быстро отреагировать на запрос, а потом дать детальный ответ "
"(пользовательский интерфейс).\n"
"* Многопользовательский сервис (каждый запрос в своём треде)."

#: slides10/src/main/asciidoc/lecture.adoc:51
msgid "== Где мы НЕ можем получить выгоду от [увеличения] concurrency?"
msgstr "== Где мы НЕ можем получить выгоду от [увеличения] concurrency?"

#: slides10/src/main/asciidoc/lecture.adoc:55
msgid ""
"* CPU-bound задача не будет решаться быстрее, если тредов больше, чем ядер.\n"
"* Задача плохо параллелизуется (упирается в неразделяемый ресурс).\n"
"* Нас ограничивает закон Амдала."
msgstr ""
"* CPU-bound задача не будет решаться быстрее, если тредов больше, чем ядер.\n"
"* Задача плохо параллелизуется (упирается в неразделяемый ресурс).\n"
"* Нас ограничивает закон Амдала."

#: slides10/src/main/asciidoc/lecture.adoc:57
msgid "== Закон Амдала (Amdahl's law)"
msgstr "== Закон Амдала (Amdahl's law)"

#: slides10/src/main/asciidoc/lecture.adoc:61
msgid ""
"* &alpha; -- доля вычислений, которая должна выполняться последовательно,\n"
"* _N_ -- число параллельных потоков выполнения,\n"
"* _S_ -- полученное ускорение (speedup)."
msgstr ""
"* &alpha; -- доля вычислений, которая должна выполняться последовательно,\n"
"* _N_ -- число параллельных потоков выполнения,\n"
"* _S_ -- полученное ускорение (speedup)."

#: slides10/src/main/asciidoc/lecture.adoc:67
msgid ""
"[stem] \n"
"++++\n"
"\\Huge\n"
"S = \\frac{1}{\\alpha+\\frac{1-\\alpha}{N}} = \\frac{N}{1+\\alpha(N-1)} "
"\\leq \\frac{1}{\\alpha}\n"
"++++"
msgstr ""
"[stem] \n"
"++++\n"
"\\Huge\n"
"S = \\frac{1}{\\alpha+\\frac{1-\\alpha}{N}} = \\frac{N}{1+\\alpha(N-1)} "
"\\leq \\frac{1}{\\alpha}\n"
"++++"

#: slides10/src/main/asciidoc/lecture.adoc:69
msgid ""
"Вывод: если разделяемая работа составляет 80%, вы не получите более чем "
"пятикратное увеличение производительности за счёт параллелизации."
msgstr ""
"Вывод: если разделяемая работа составляет 80%, вы не получите более чем "
"пятикратное увеличение производительности за счёт параллелизации."

#: slides10/src/main/asciidoc/lecture.adoc:71
msgid "== Закон Амдала: поведение"
msgstr "== Закон Амдала: поведение"

#: slides10/src/main/asciidoc/lecture.adoc:73
msgid "image::amdahl.png[{image-70-width}]"
msgstr "image::amdahl.png[{image-70-width}]"

#: slides10/src/main/asciidoc/lecture.adoc:75
msgctxt "./slides10/src/main/asciidoc/lecture.adoc:75"
msgid "== На самом деле, всё ещё хуже! "
msgstr "== На самом деле, всё ещё хуже! "

#: slides10/src/main/asciidoc/lecture.adoc:102
msgid ""
"[cols=\"25a,25a,25a,25a\"]\n"
"|===\n"
"^.^|\n"
"[stem]\n"
"++++\n"
"\\Large\n"
"N = 4, E = 6\n"
"++++\n"
"^.^|\n"
"[stem]\n"
"++++\n"
"\\Large\n"
"N = 5, E = 10\n"
"++++\n"
"^.^|\n"
"[stem]\n"
"++++\n"
"\\Large\n"
"N = 6, E = 15\n"
"++++\n"
"^.^|\n"
"[stem]\n"
"++++\n"
"\\Large\n"
"N = 7, E = 21\n"
"++++"
msgstr ""
"[cols=\"25a,25a,25a,25a\"]\n"
"|===\n"
"^.^|\n"
"[stem]\n"
"++++\n"
"\\Large\n"
"N = 4, E = 6\n"
"++++\n"
"^.^|\n"
"[stem]\n"
"++++\n"
"\\Large\n"
"N = 5, E = 10\n"
"++++\n"
"^.^|\n"
"[stem]\n"
"++++\n"
"\\Large\n"
"N = 6, E = 15\n"
"++++\n"
"^.^|\n"
"[stem]\n"
"++++\n"
"\\Large\n"
"N = 7, E = 21\n"
"++++"

#: slides10/src/main/asciidoc/lecture.adoc:115
msgid ""
"^.^|\n"
"[graphviz,\"k4.png\"]\n"
"----\n"
"graph K4 {\n"
"    graph [ dpi = 180 ];\n"
"    layout=circo;\n"
"    node[shape=point];\n"
"    a--b; a--c; a--d;\n"
"    b--c; b--d;\n"
"    c--d;\n"
"}\n"
"----"
msgstr ""
"^.^|\n"
"[graphviz,\"k4.png\"]\n"
"----\n"
"graph K4 {\n"
"    graph [ dpi = 180 ];\n"
"    layout=circo;\n"
"    node[shape=point];\n"
"    a--b; a--c; a--d;\n"
"    b--c; b--d;\n"
"    c--d;\n"
"}\n"
"----"

#: slides10/src/main/asciidoc/lecture.adoc:117
msgctxt "./slides10/src/main/asciidoc/lecture.adoc:117"
msgid "^.^|"
msgstr "^.^|"

#: slides10/src/main/asciidoc/lecture.adoc:130
msgid ""
"[graphviz,\"k5.png\"]\n"
"----\n"
"graph K5 {\n"
"    graph [ dpi = 180 ];\n"
"    layout=circo;\n"
"    node[shape=point];\n"
"    a--b; a--c; a--d; a--e;\n"
"    b--c; b--d; b--e;\n"
"    c--d; c--e;\n"
"    d--e;\n"
"}\n"
"----"
msgstr ""
"[graphviz,\"k5.png\"]\n"
"----\n"
"graph K5 {\n"
"    graph [ dpi = 180 ];\n"
"    layout=circo;\n"
"    node[shape=point];\n"
"    a--b; a--c; a--d; a--e;\n"
"    b--c; b--d; b--e;\n"
"    c--d; c--e;\n"
"    d--e;\n"
"}\n"
"----"

#: slides10/src/main/asciidoc/lecture.adoc:132
msgctxt "./slides10/src/main/asciidoc/lecture.adoc:132"
msgid "^.^|"
msgstr "^.^|"

#: slides10/src/main/asciidoc/lecture.adoc:145
msgid ""
"[graphviz,\"k6.png\"]\n"
"----\n"
"graph K6 {\n"
"    graph [ dpi = 180 ];\n"
"    layout=circo;\n"
"    node[shape=point];\n"
"    a--b; a--c; a--d; a--e; a--f;\n"
"    b--c; b--d; b--e; b--f;\n"
"    c--d; c--e; c--f;\n"
"    d--e; d--f;\n"
"    e--f;\n"
"}"
msgstr ""
"[graphviz,\"k6.png\"]\n"
"----\n"
"graph K6 {\n"
"    graph [ dpi = 180 ];\n"
"    layout=circo;\n"
"    node[shape=point];\n"
"    a--b; a--c; a--d; a--e; a--f;\n"
"    b--c; b--d; b--e; b--f;\n"
"    c--d; c--e; c--f;\n"
"    d--e; d--f;\n"
"    e--f;\n"
"}"

#: slides10/src/main/asciidoc/lecture.adoc:148
msgctxt "./slides10/src/main/asciidoc/lecture.adoc:148"
msgid "^.^|"
msgstr "^.^|"

#: slides10/src/main/asciidoc/lecture.adoc:164
msgid ""
"[graphviz,\"k7.png\"]\n"
"----\n"
"graph K7 {\n"
"    graph [ dpi = 180 ];\n"
"    layout=circo;\n"
"    node[shape=point];\n"
"    a--b; a--c; a--d; a--e; a--f; a--g;\n"
"    b--c; b--d; b--e; b--f; b--g;\n"
"    c--d; c--e; c--f; c--g;\n"
"    d--e; d--f; d--g;\n"
"    e--f; e--g;\n"
"    f--g;\n"
"}\n"
"----\n"
"|==="
msgstr ""
"[graphviz,\"k7.png\"]\n"
"----\n"
"graph K7 {\n"
"    graph [ dpi = 180 ];\n"
"    layout=circo;\n"
"    node[shape=point];\n"
"    a--b; a--c; a--d; a--e; a--f; a--g;\n"
"    b--c; b--d; b--e; b--f; b--g;\n"
"    c--d; c--e; c--f; c--g;\n"
"    d--e; d--f; d--g;\n"
"    e--f; e--g;\n"
"    f--g;\n"
"}\n"
"----\n"
"|==="

#: slides10/src/main/asciidoc/lecture.adoc:170
msgid ""
"[stem] \n"
"++++\n"
"\\Huge\n"
"E = \\frac{N (N -1)}{2}\n"
"++++"
msgstr ""
"[stem] \n"
"++++\n"
"\\Huge\n"
"E = \\frac{N (N -1)}{2}\n"
"++++"

#: slides10/src/main/asciidoc/lecture.adoc:172
msgctxt "./slides10/src/main/asciidoc/lecture.adoc:172"
msgid "== На самом деле, всё ещё хуже! "
msgstr "== На самом деле, всё ещё хуже! "

#: slides10/src/main/asciidoc/lecture.adoc:176
msgid ""
"* Uiversal Scalability Law -- полуэмпирическое обобщение закона Амдала\n"
"* &beta; -- параметр, определяющий cohesion (межпоточную координацию)\n"
"* хорошо ложится на эмпирические данные"
msgstr ""
"* Uiversal Scalability Law -- полуэмпирическое обобщение закона Амдала\n"
"* &beta; -- параметр, определяющий cohesion (межпоточную координацию)\n"
"* хорошо ложится на эмпирические данные"

#: slides10/src/main/asciidoc/lecture.adoc:183
msgid ""
"[stem] \n"
"++++\n"
"\\Large\n"
"S = \\frac{N}{1+\\alpha(N-1) + \\beta N (N-1)} = \\frac{N}{1+(\\alpha + "
"\\beta N) (N-1)}\n"
"++++\n"
"== USL: поведение"
msgstr ""
"[stem] \n"
"++++\n"
"\\Large\n"
"S = \\frac{N}{1+\\alpha(N-1) + \\beta N (N-1)} = \\frac{N}{1+(\\alpha + "
"\\beta N) (N-1)}\n"
"++++\n"
"== USL: поведение"

#: slides10/src/main/asciidoc/lecture.adoc:185
msgid "image::usl.png[{image-70-width}]"
msgstr "image::usl.png[{image-70-width}]"

#: slides10/src/main/asciidoc/lecture.adoc:187
msgid "== Промежуточный вывод"
msgstr "== Промежуточный вывод"

#: slides10/src/main/asciidoc/lecture.adoc:192
msgid ""
"* Перед тем, как встать на скользкую тропу многопоточного программирования, "
"подумайте: \n"
"** нужно ли это для решения задачи?\n"
"** насколько многопоточным должно быть решение?\n"
"* Вас предупредили."
msgstr ""
"* Перед тем, как встать на скользкую тропу многопоточного программирования, "
"подумайте: \n"
"** нужно ли это для решения задачи?\n"
"** насколько многопоточным должно быть решение?\n"
"* Вас предупредили."

#: slides10/src/main/asciidoc/lecture.adoc:194
msgid "image::hydra1.jpg[{image-40-width}]"
msgstr "image::hydra1.jpg[{image-40-width}]"

#: slides10/src/main/asciidoc/lecture.adoc:196
msgid "//https://www.ancient.eu/img/r/p/750x750/3359.jpg?v=1539676109"
msgstr "//https://www.ancient.eu/img/r/p/750x750/3359.jpg?v=1539676109"

#: slides10/src/main/asciidoc/lecture.adoc:199
msgid "== Часть 1. Зачем нужна и как достигается синхронизация"
msgstr "== Часть 1. Зачем нужна и как достигается синхронизация"

#: slides10/src/main/asciidoc/lecture.adoc:201
msgctxt "./slides10/src/main/asciidoc/lecture.adoc:201"
msgid "image::hydra2.jpg[{image-90-width}]"
msgstr "image::hydra2.jpg[{image-90-width}]"

#: slides10/src/main/asciidoc/lecture.adoc:204
msgid ""
"[[first_example]]\n"
"== Многопоточность в Java (с самой первой версии!)"
msgstr ""
"[[first_example]]\n"
"== Многопоточность в Java (с самой первой версии!)"

#: slides10/src/main/asciidoc/lecture.adoc:208
msgid ""
"[plantuml, runthr, png]\n"
"----\n"
"@startuml"
msgstr ""
"[plantuml, runthr, png]\n"
"----\n"
"@startuml"

#: slides10/src/main/asciidoc/lecture.adoc:210
msgid "skinparam dpi 150 "
msgstr "skinparam dpi 150 "

#: slides10/src/main/asciidoc/lecture.adoc:214
msgid ""
"interface Runnable {\n"
"  void run()\n"
"}"
msgstr ""
"interface Runnable {\n"
"  void run()\n"
"}"

#: slides10/src/main/asciidoc/lecture.adoc:221
msgid ""
"class Thread {\n"
"  void start()\n"
"  void join([long millis]) throws InterruptedException\n"
"  void interrupt()\n"
"  Thread.state getState()\n"
"}"
msgstr ""
"class Thread {\n"
"  void start()\n"
"  void join([long millis]) throws InterruptedException\n"
"  void interrupt()\n"
"  Thread.state getState()\n"
"}"

#: slides10/src/main/asciidoc/lecture.adoc:224
msgid "Runnable <|- Thread"
msgstr "Runnable <|- Thread"

#: slides10/src/main/asciidoc/lecture.adoc:227
msgctxt "./slides10/src/main/asciidoc/lecture.adoc:227"
msgid ""
"@enduml\n"
"----"
msgstr ""
"@enduml\n"
"----"

#: slides10/src/main/asciidoc/lecture.adoc:243
msgid ""
"[source,java]\n"
"----\n"
"class CalcSquare extends Thread {\n"
"    final int argument;\n"
"    int result;\n"
"    CalcSquare(int argument) {\n"
"        this.argument = argument;\n"
"    }\n"
"    @Override\n"
"    public void run() {\n"
"        //«сложные» вычисления\n"
"        result = argument * argument;\n"
"    }\n"
"}\n"
"----"
msgstr ""
"[source,java]\n"
"----\n"
"class CalcSquare extends Thread {\n"
"    final int argument;\n"
"    int result;\n"
"    CalcSquare(int argument) {\n"
"        this.argument = argument;\n"
"    }\n"
"    @Override\n"
"    public void run() {\n"
"        //«сложные» вычисления\n"
"        result = argument * argument;\n"
"    }\n"
"}\n"
"----"

#: slides10/src/main/asciidoc/lecture.adoc:245
msgid "== Запуск параллельных вычислений через Thread API"
msgstr "== Запуск параллельных вычислений через Thread API"

#: slides10/src/main/asciidoc/lecture.adoc:247
msgid "* NB: в современной реальности вы не будете пользоваться Thread API"
msgstr "* NB: в современной реальности вы не будете пользоваться Thread API"

#: slides10/src/main/asciidoc/lecture.adoc:259
msgid ""
"[source,java]\n"
"----\n"
"CalcSquare t1 = new CalcSquare(2);\n"
"CalcSquare t2 = new CalcSquare(3);\n"
"t1.start();\n"
"t2.start();\n"
"t1.join();\n"
"t2.join();\n"
"System.out.printf(\"%d, %d%n\", t1.result, t2.result);\n"
"//otput: 4, 9\n"
"----"
msgstr ""
"[source,java]\n"
"----\n"
"CalcSquare t1 = new CalcSquare(2);\n"
"CalcSquare t2 = new CalcSquare(3);\n"
"t1.start();\n"
"t2.start();\n"
"t1.join();\n"
"t2.join();\n"
"System.out.printf(\"%d, %d%n\", t1.result, t2.result);\n"
"//otput: 4, 9\n"
"----"

#: slides10/src/main/asciidoc/lecture.adoc:262
msgid "== Проблемы с shared state"
msgstr "== Проблемы с shared state"

#: slides10/src/main/asciidoc/lecture.adoc:271
msgid ""
"[cols=\"50a,.^50a\"]\n"
"|===\n"
"|image::hydraheads.jpg[]\n"
"|\n"
"* Race condition\n"
"* Stale values\n"
"* Reordering\n"
"|==="
msgstr ""
"[cols=\"50a,.^50a\"]\n"
"|===\n"
"|image::hydraheads.jpg[]\n"
"|\n"
"* Race condition\n"
"* Stale values\n"
"* Reordering\n"
"|==="

#: slides10/src/main/asciidoc/lecture.adoc:273
msgid "== Race condition"
msgstr "== Race condition"

#: slides10/src/main/asciidoc/lecture.adoc:282
msgid ""
"[source,java]\n"
"----\n"
"class DumbCounter {\n"
"  int count;\n"
"  void increment(){\n"
"    count++;\n"
"  }\n"
"}"
msgstr ""
"[source,java]\n"
"----\n"
"class DumbCounter {\n"
"  int count;\n"
"  void increment(){\n"
"    count++;\n"
"  }\n"
"}"

#: slides10/src/main/asciidoc/lecture.adoc:285
msgid ""
"DumbCounter c1 = new DumbCounter();\n"
"IntStream.range(0, 1000000).forEach(i->c1.increment());"
msgstr ""
"DumbCounter c1 = new DumbCounter();\n"
"IntStream.range(0, 1000000).forEach(i->c1.increment());"

#: slides10/src/main/asciidoc/lecture.adoc:288
msgid ""
"DumbCounter c2 = new DumbCounter();\n"
"IntStream.range(0, 1000000).parallel().forEach(i->c2.increment());"
msgstr ""
"DumbCounter c2 = new DumbCounter();\n"
"IntStream.range(0, 1000000).parallel().forEach(i->c2.increment());"

#: slides10/src/main/asciidoc/lecture.adoc:290
msgid "System.out.printf(\"%d, %d%n\", c1.count, c2.count);"
msgstr "System.out.printf(\"%d, %d%n\", c1.count, c2.count);"

#: slides10/src/main/asciidoc/lecture.adoc:293
msgid ""
"//1000000,??????\n"
"----"
msgstr ""
"//1000000,??????\n"
"----"

#: slides10/src/main/asciidoc/lecture.adoc:296
msgid "== Stale values"
msgstr "== Stale values"

#: slides10/src/main/asciidoc/lecture.adoc:301
msgid ""
"[source,java]\n"
"----\n"
"class DumbWayToFallAsleep implements Runnable {\n"
"  private boolean asleep;"
msgstr ""
"[source,java]\n"
"----\n"
"class DumbWayToFallAsleep implements Runnable {\n"
"  private boolean asleep;"

#: slides10/src/main/asciidoc/lecture.adoc:305
msgctxt "./slides10/src/main/asciidoc/lecture.adoc:305"
msgid ""
"  public void setAsleep(boolean asleep){\n"
"    this.asleep = asleep;\n"
"  }"
msgstr ""
"  public void setAsleep(boolean asleep){\n"
"    this.asleep = asleep;\n"
"  }"

#: slides10/src/main/asciidoc/lecture.adoc:315
msgid ""
"  @Override\n"
"  public void run() {\n"
"    while (!asleep){\n"
"      //countSomeSheep\n"
"      //УСНЁМ ЛИ МЫ?\n"
"    }\n"
"  }\n"
"}\n"
"----"
msgstr ""
"  @Override\n"
"  public void run() {\n"
"    while (!asleep){\n"
"      //countSomeSheep\n"
"      //УСНЁМ ЛИ МЫ?\n"
"    }\n"
"  }\n"
"}\n"
"----"

#: slides10/src/main/asciidoc/lecture.adoc:318
msgid "== Reordering"
msgstr "== Reordering"

#: slides10/src/main/asciidoc/lecture.adoc:339
msgid ""
"[source,java]\n"
"----\n"
"class PossibleReordering {\n"
"  static int x = 0, y = 0, a = 0, b = 0;\n"
"  public static void main(String... args) \n"
"                throws InterruptedException {\n"
"    //другой способ запуска треда (тоже не будете пользоваться)\n"
"    Thread one = new Thread(() -> {\n"
"        a = 1; x = b;\n"
"    });\n"
"    Thread two = new Thread(() -> {\n"
"        b = 1; y = a;\n"
"    });\n"
"    one.start(); two.start();\n"
"    one.join();  two.join();\n"
"    System.out.printf(\"%d,%d\", x, y);\n"
"    //??,??\n"
"  }\n"
"}\n"
"----"
msgstr ""
"[source,java]\n"
"----\n"
"class PossibleReordering {\n"
"  static int x = 0, y = 0, a = 0, b = 0;\n"
"  public static void main(String... args) \n"
"                throws InterruptedException {\n"
"    //другой способ запуска треда (тоже не будете пользоваться)\n"
"    Thread one = new Thread(() -> {\n"
"        a = 1; x = b;\n"
"    });\n"
"    Thread two = new Thread(() -> {\n"
"        b = 1; y = a;\n"
"    });\n"
"    one.start(); two.start();\n"
"    one.join();  two.join();\n"
"    System.out.printf(\"%d,%d\", x, y);\n"
"    //??,??\n"
"  }\n"
"}\n"
"----"

#: slides10/src/main/asciidoc/lecture.adoc:342
msgid "== Промежуточные выводы"
msgstr "== Промежуточные выводы"

#: slides10/src/main/asciidoc/lecture.adoc:344
msgid ""
"* Из-за reordering и других низкоуровневых особенностей _нельзя_ рассуждать "
"о результате работы одного треда с точки зрения другого треда как о "
"промежуточном результате выполнения исходного кода. "
msgstr ""
"* Из-за reordering и других низкоуровневых особенностей _нельзя_ рассуждать "
"о результате работы одного треда с точки зрения другого треда как о "
"промежуточном результате выполнения исходного кода. "

#: slides10/src/main/asciidoc/lecture.adoc:346
msgid "* Все проблемы с параллельными вычислениями связаны с shared state."
msgstr "* Все проблемы с параллельными вычислениями связаны с shared state."

#: slides10/src/main/asciidoc/lecture.adoc:348
msgid "* Показанные здесь проблемы проявляются недетерминированно."
msgstr "* Показанные здесь проблемы проявляются недетерминированно."

#: slides10/src/main/asciidoc/lecture.adoc:350
msgid ""
"* Любая программа с доступом к shared state без должной синхронизации -- "
"_сломана_, даже если «вчера это работало на моей машине»."
msgstr ""
"* Любая программа с доступом к shared state без должной синхронизации -- "
"_сломана_, даже если «вчера это работало на моей машине»."

#: slides10/src/main/asciidoc/lecture.adoc:352
msgid "== Модель памяти"
msgstr "== Модель памяти"

#: slides10/src/main/asciidoc/lecture.adoc:357
msgid ""
"[source,java]\n"
"----\n"
"int aVariable = 42; \n"
"----"
msgstr ""
"[source,java]\n"
"----\n"
"int aVariable = 42; \n"
"----"

#: slides10/src/main/asciidoc/lecture.adoc:359
msgid ""
"* Модель памяти (Java Memory Model, JMM) -- спецификация языка и виртуальной "
"машины, отвечающая на вопрос: «при каких условиях поток, читающий переменную "
"`aVariable`, увидит значение 42?»"
msgstr ""
"* Модель памяти (Java Memory Model, JMM) -- спецификация языка и виртуальной "
"машины, отвечающая на вопрос: «при каких условиях поток, читающий переменную "
"`aVariable`, увидит значение 42?»"

#: slides10/src/main/asciidoc/lecture.adoc:361
msgid "== Happens-before"
msgstr "== Happens-before"

#: slides10/src/main/asciidoc/lecture.adoc:363
msgid ""
"* JMM определяет частичный порядок на всех действиях в Java-программе, "
"называемый _happens-before_."
msgstr ""
"* JMM определяет частичный порядок на всех действиях в Java-программе, "
"называемый _happens-before_."

#: slides10/src/main/asciidoc/lecture.adoc:365
msgid ""
"* Отношение _happens-before_ транзитивно: stem:[A \\prec B \\wedge B \\prec "
"C \\Rightarrow A \\prec C]"
msgstr ""
"* Отношение _happens-before_ транзитивно: stem:[A \\prec B \\wedge B \\prec "
"C \\Rightarrow A \\prec C]"

#: slides10/src/main/asciidoc/lecture.adoc:367
msgid ""
"* Чтобы действие B гарантированно видело результат работы действия A, "
"достаточно, чтобы stem:[A \\prec B]."
msgstr ""
"* Чтобы действие B гарантированно видело результат работы действия A, "
"достаточно, чтобы stem:[A \\prec B]."

#: slides10/src/main/asciidoc/lecture.adoc:369
msgid "== Program order rule"
msgstr "== Program order rule"

#: slides10/src/main/asciidoc/lecture.adoc:371
msgid ""
"* В рамках одного треда все действия _happens-before_ в порядке их "
"определения в исходном коде программы. "
msgstr ""
"* В рамках одного треда все действия _happens-before_ в порядке их "
"определения в исходном коде программы. "

#: slides10/src/main/asciidoc/lecture.adoc:373
msgid "* Иными словами, однопоточные программы выполняются без сюрпризов."
msgstr "* Иными словами, однопоточные программы выполняются без сюрпризов."

#: slides10/src/main/asciidoc/lecture.adoc:375
msgid "== Thread start & thread termination rule"
msgstr "== Thread start & thread termination rule"

#: slides10/src/main/asciidoc/lecture.adoc:379
msgid ""
"* Вызов `threadA.start()` _happens-before_ всех операций в потоке "
"`threadA`.\n"
"* Любая операция в потоке `threadA` _happens-before_ обнаружения другим "
"потоком завершения `threadA`, либо путём выхода из `threadA.join()`, либо "
"путём проверки `threadA.isAlive() == false`.\n"
"* Благодаря этому правилу, <<first_example,наш самый первый пример>> на "
"параллелизацию работает корректно."
msgstr ""
"* Вызов `threadA.start()` _happens-before_ всех операций в потоке "
"`threadA`.\n"
"* Любая операция в потоке `threadA` _happens-before_ обнаружения другим "
"потоком завершения `threadA`, либо путём выхода из `threadA.join()`, либо "
"путём проверки `threadA.isAlive() == false`.\n"
"* Благодаря этому правилу, <<first_example,наш самый первый пример>> на "
"параллелизацию работает корректно."

#: slides10/src/main/asciidoc/lecture.adoc:382
msgid "== Ключевое слово volatile"
msgstr "== Ключевое слово volatile"

#: slides10/src/main/asciidoc/lecture.adoc:384
msgid ""
"* Переменные классов могут быть определены с ключевым словом `volatile`."
msgstr ""
"* Переменные классов могут быть определены с ключевым словом `volatile`."

#: slides10/src/main/asciidoc/lecture.adoc:386
msgid ""
"* *Запись в `volatile`-переменную _happens-before_ чтения из этой переменной "
"в другом потоке.*"
msgstr ""
"* *Запись в `volatile`-переменную _happens-before_ чтения из этой переменной "
"в другом потоке.*"

#: slides10/src/main/asciidoc/lecture.adoc:388
msgid ""
"* Это автоматом делает видимыми изменения в других переменных. Полагаться на "
"это не рекомендуется: это работает, но делает код хрупким. В процессе "
"рефакторинга можно поменять порядок доступа к переменным и тем самым "
"незаметно поломать программу. "
msgstr ""
"* Это автоматом делает видимыми изменения в других переменных. Полагаться на "
"это не рекомендуется: это работает, но делает код хрупким. В процессе "
"рефакторинга можно поменять порядок доступа к переменным и тем самым "
"незаметно поломать программу. "

#: slides10/src/main/asciidoc/lecture.adoc:390
msgid "== Чиним stale value при помощи volatile"
msgstr "== Чиним stale value при помощи volatile"

#: slides10/src/main/asciidoc/lecture.adoc:395
msgid ""
"[source,java]\n"
"----\n"
"class NotSoDumbWayToFallAsleep implements Runnable {\n"
"  private volatile boolean asleep;"
msgstr ""
"[source,java]\n"
"----\n"
"class NotSoDumbWayToFallAsleep implements Runnable {\n"
"  private volatile boolean asleep;"

#: slides10/src/main/asciidoc/lecture.adoc:399
msgctxt "./slides10/src/main/asciidoc/lecture.adoc:399"
msgid ""
"  public void setAsleep(boolean asleep){\n"
"    this.asleep = asleep;\n"
"  }"
msgstr ""
"  public void setAsleep(boolean asleep){\n"
"    this.asleep = asleep;\n"
"  }"

#: slides10/src/main/asciidoc/lecture.adoc:409
msgid ""
"  @Override\n"
"  public void run() {\n"
"    while (!asleep){\n"
"      //countSomeSheep\n"
"      //...\n"
"    }\n"
"  }\n"
"}\n"
"----"
msgstr ""
"  @Override\n"
"  public void run() {\n"
"    while (!asleep){\n"
"      //countSomeSheep\n"
"      //...\n"
"    }\n"
"  }\n"
"}\n"
"----"

#: slides10/src/main/asciidoc/lecture.adoc:411
msgid "== final-поля"
msgstr "== final-поля"

#: slides10/src/main/asciidoc/lecture.adoc:413
msgid ""
"* Если объект правильно опубликован, т. е.  _ссылка на него не утекает во "
"время выполнения конструктора_ --  `final`-поля объекта доступны всем тредам "
"без синхронизации."
msgstr ""
"* Если объект правильно опубликован, т. е.  _ссылка на него не утекает во "
"время выполнения конструктора_ --  `final`-поля объекта доступны всем тредам "
"без синхронизации."

#: slides10/src/main/asciidoc/lecture.adoc:415
msgid ""
"* Лучший способ борьбы с проблемами mutable state -- использовать immutable "
"state где только возможно."
msgstr ""
"* Лучший способ борьбы с проблемами mutable state -- использовать immutable "
"state где только возможно."

#: slides10/src/main/asciidoc/lecture.adoc:417
msgid "== Неатомарные операции: final не годится, volatile не спасёт"
msgstr "== Неатомарные операции: final не годится, volatile не спасёт"

#: slides10/src/main/asciidoc/lecture.adoc:431
msgid ""
"[cols=\"50a,50a\"]\n"
"|===\n"
"|\n"
"[source,java]\n"
"----\n"
"class DumbCounter {\n"
"  int count;\n"
"  void increment(){\n"
"    count++;\n"
"  }\n"
"}\n"
"----\n"
"(Мы можем объявить `count` как volatile, но ситуация не улучшится.)"
msgstr ""
"[cols=\"50a,50a\"]\n"
"|===\n"
"|\n"
"[source,java]\n"
"----\n"
"class DumbCounter {\n"
"  int count;\n"
"  void increment(){\n"
"    count++;\n"
"  }\n"
"}\n"
"----\n"
"(Мы можем объявить `count` как volatile, но ситуация не улучшится.)"

#: slides10/src/main/asciidoc/lecture.adoc:436
msgid ""
"|[source,java]\n"
"----\n"
"void dumbMoneyTransfer(\n"
"  int from, int to, int amount){"
msgstr ""
"|[source,java]\n"
"----\n"
"void dumbMoneyTransfer(\n"
"  int from, int to, int amount){"

#: slides10/src/main/asciidoc/lecture.adoc:441
msgid ""
"    accounts[from]-=amount;\n"
"    accounts[to]+=amount;\n"
"}\n"
"----"
msgstr ""
"    accounts[from]-=amount;\n"
"    accounts[to]+=amount;\n"
"}\n"
"----"

#: slides10/src/main/asciidoc/lecture.adoc:444
msgid ""
"(Кстати, `volatile array` -- не массив `volatile`-элементов. И вообще в Java "
"просто так массив `volatile`-элементов не создать.)\n"
"|==="
msgstr ""
"(Кстати, `volatile array` -- не массив `volatile`-элементов. И вообще в Java "
"просто так массив `volatile`-элементов не создать.)\n"
"|==="

#: slides10/src/main/asciidoc/lecture.adoc:454
msgid ""
"== Несинхронизированное выполнение\n"
"[plantuml, nonsync, png]\n"
"----\n"
"@startuml\n"
"skinparam dpi 180\n"
"participant Client1\n"
"participant Client2\n"
"participant Bank"
msgstr ""
"== Несинхронизированное выполнение\n"
"[plantuml, nonsync, png]\n"
"----\n"
"@startuml\n"
"skinparam dpi 180\n"
"participant Client1\n"
"participant Client2\n"
"participant Bank"

#: slides10/src/main/asciidoc/lecture.adoc:457
msgctxt "./slides10/src/main/asciidoc/lecture.adoc:457"
msgid ""
"Client1 -> Bank: transfer\n"
"activate Bank"
msgstr ""
"Client1 -> Bank: transfer\n"
"activate Bank"

#: slides10/src/main/asciidoc/lecture.adoc:460
msgid ""
"Client2 -> Bank: transfer\n"
"Bank --> Client1 "
msgstr ""
"Client2 -> Bank: transfer\n"
"Bank --> Client1 "

#: slides10/src/main/asciidoc/lecture.adoc:464
msgid ""
"Bank --> Client2\n"
"deactivate Bank"
msgstr ""
"Bank --> Client2\n"
"deactivate Bank"

#: slides10/src/main/asciidoc/lecture.adoc:467
msgctxt "./slides10/src/main/asciidoc/lecture.adoc:467"
msgid ""
"@enduml\n"
"----"
msgstr ""
"@enduml\n"
"----"

#: slides10/src/main/asciidoc/lecture.adoc:477
msgid ""
"== Синхронизированное выполнение\n"
"[plantuml, sync, png]\n"
"----\n"
"@startuml\n"
"skinparam dpi 180\n"
"participant Client1\n"
"participant Client2\n"
"participant Lock\n"
"participant Bank"
msgstr ""
"== Синхронизированное выполнение\n"
"[plantuml, sync, png]\n"
"----\n"
"@startuml\n"
"skinparam dpi 180\n"
"participant Client1\n"
"participant Client2\n"
"participant Lock\n"
"participant Bank"

#: slides10/src/main/asciidoc/lecture.adoc:483
msgid ""
"Client1 -> Lock: lock\n"
"activate Lock\n"
"Lock --> Client1\n"
"deactivate Lock"
msgstr ""
"Client1 -> Lock: lock\n"
"activate Lock\n"
"Lock --> Client1\n"
"deactivate Lock"

#: slides10/src/main/asciidoc/lecture.adoc:486
msgctxt "./slides10/src/main/asciidoc/lecture.adoc:486"
msgid ""
"Client1 -> Bank: transfer\n"
"activate Bank"
msgstr ""
"Client1 -> Bank: transfer\n"
"activate Bank"

#: slides10/src/main/asciidoc/lecture.adoc:489
msgid ""
"Client2 -> Lock: lock\n"
"activate Lock"
msgstr ""
"Client2 -> Lock: lock\n"
"activate Lock"

#: slides10/src/main/asciidoc/lecture.adoc:492
msgid ""
"Bank --> Client1 \n"
"deactivate Bank"
msgstr ""
"Bank --> Client1 \n"
"deactivate Bank"

#: slides10/src/main/asciidoc/lecture.adoc:497
msgid ""
"Client1 -> Lock: unlock\n"
"Lock --> Client1\n"
"Lock --> Client2\n"
"deactivate Lock"
msgstr ""
"Client1 -> Lock: unlock\n"
"Lock --> Client1\n"
"Lock --> Client2\n"
"deactivate Lock"

#: slides10/src/main/asciidoc/lecture.adoc:502
msgid ""
"Client2 -> Bank: transfer\n"
"activate Bank\n"
"Bank --> Client2\n"
"deactivate Bank"
msgstr ""
"Client2 -> Bank: transfer\n"
"activate Bank\n"
"Bank --> Client2\n"
"deactivate Bank"

#: slides10/src/main/asciidoc/lecture.adoc:505
msgctxt "./slides10/src/main/asciidoc/lecture.adoc:505"
msgid ""
"@enduml\n"
"----"
msgstr ""
"@enduml\n"
"----"

#: slides10/src/main/asciidoc/lecture.adoc:508
msgid "== Блокировки"
msgstr "== Блокировки"

#: slides10/src/main/asciidoc/lecture.adoc:514
msgid ""
"[source,java]\n"
"----\n"
"//Reentrant так называется потому,\n"
"//что одному и тому же треду позволено входить повторно\n"
"private ReentrantLock bankLock = new ReentrantLock(); "
msgstr ""
"[source,java]\n"
"----\n"
"//Reentrant так называется потому,\n"
"//что одному и тому же треду позволено входить повторно\n"
"private ReentrantLock bankLock = new ReentrantLock(); "

#: slides10/src/main/asciidoc/lecture.adoc:527
msgid ""
"void moneyTransfer(int from, int to, int amount) {\n"
"  bankLock.lock();\n"
"  try {\n"
"    accounts[from]-=amount;\n"
"    accounts[to]+=amount;\n"
"  } finally {\n"
"    bankLock.unlock();\n"
"  }\n"
"}\n"
"----\n"
"[.fragment]\n"
"Если вы задались вопросом: «где гарантии, что после выхода из блокировки "
"тред увидит результат работы предыдущего треда?» -- поздравляю, вы начали "
"что-то понимать."
msgstr ""
"void moneyTransfer(int from, int to, int amount) {\n"
"  bankLock.lock();\n"
"  try {\n"
"    accounts[from]-=amount;\n"
"    accounts[to]+=amount;\n"
"  } finally {\n"
"    bankLock.unlock();\n"
"  }\n"
"}\n"
"----\n"
"[.fragment]\n"
"Если вы задались вопросом: «где гарантии, что после выхода из блокировки "
"тред увидит результат работы предыдущего треда?» -- поздравляю, вы начали "
"что-то понимать."

#: slides10/src/main/asciidoc/lecture.adoc:529
msgid "== JMM Monitor Lock Rule"
msgstr "== JMM Monitor Lock Rule"

#: slides10/src/main/asciidoc/lecture.adoc:532
msgid ""
"* Разблокировка (unlocking) _happens-before_ другой блокировки (locking) "
"того же самого «замка» (lock).\n"
"* Поэтому защищённые блокировкой переменные объявлять как `volatile` уже не "
"нужно."
msgstr ""
"* Разблокировка (unlocking) _happens-before_ другой блокировки (locking) "
"того же самого «замка» (lock).\n"
"* Поэтому защищённые блокировкой переменные объявлять как `volatile` уже не "
"нужно."

#: slides10/src/main/asciidoc/lecture.adoc:534
msgid "== В чём проблема здесь?"
msgstr "== В чём проблема здесь?"

#: slides10/src/main/asciidoc/lecture.adoc:540
msgid ""
"[source,java]\n"
"----\n"
"while (accounts[from] < amount) {\n"
"    //wait ....\n"
"}"
msgstr ""
"[source,java]\n"
"----\n"
"while (accounts[from] < amount) {\n"
"    //wait ....\n"
"}"

#: slides10/src/main/asciidoc/lecture.adoc:550
msgid ""
"bankLock.lock();\n"
"try {\n"
"  //transfer funds ...\n"
"} finally {\n"
"  bankLock.unlock();\n"
"}\n"
"----\n"
"[.fragment]\n"
"Доступ к `accounts[from]` не синхронизирован, но даже если бы он был "
"синхронизирован, кто-то смог бы уменьшить количество денег до вхождения в "
"блок transfer funds."
msgstr ""
"bankLock.lock();\n"
"try {\n"
"  //transfer funds ...\n"
"} finally {\n"
"  bankLock.unlock();\n"
"}\n"
"----\n"
"[.fragment]\n"
"Доступ к `accounts[from]` не синхронизирован, но даже если бы он был "
"синхронизирован, кто-то смог бы уменьшить количество денег до вхождения в "
"блок transfer funds."

#: slides10/src/main/asciidoc/lecture.adoc:552
msgid "== В чём пробема здесь?"
msgstr "== В чём пробема здесь?"

#: slides10/src/main/asciidoc/lecture.adoc:567
msgid ""
"[source,java]\n"
"----\n"
"bankLock.lock();\n"
"try {\n"
"  while (accounts[from] < amount) {\n"
"    //wait ....\n"
"  }\n"
"  //transfer funds ...\n"
"} finally {\n"
"  bankLock.unlock();\n"
"}\n"
"----\n"
"[.fragment]\n"
"Мы заблокировали `bankLock` и ждём, пока кто-то закинет денег. Но никто "
"никогда не сможет это сделать, т. к. `bankLock` занят нами."
msgstr ""
"[source,java]\n"
"----\n"
"bankLock.lock();\n"
"try {\n"
"  while (accounts[from] < amount) {\n"
"    //wait ....\n"
"  }\n"
"  //transfer funds ...\n"
"} finally {\n"
"  bankLock.unlock();\n"
"}\n"
"----\n"
"[.fragment]\n"
"Мы заблокировали `bankLock` и ждём, пока кто-то закинет денег. Но никто "
"никогда не сможет это сделать, т. к. `bankLock` занят нами."

#: slides10/src/main/asciidoc/lecture.adoc:569
msgid "== Condition Objects"
msgstr "== Condition Objects"

#: slides10/src/main/asciidoc/lecture.adoc:574
msgid ""
"[source,java]\n"
"----\n"
"private ReentrantLock bankLock = new ReentrantLock(); \n"
"private Condition sufficientFunds = bankLock.newCondition();"
msgstr ""
"[source,java]\n"
"----\n"
"private ReentrantLock bankLock = new ReentrantLock(); \n"
"private Condition sufficientFunds = bankLock.newCondition();"

#: slides10/src/main/asciidoc/lecture.adoc:580
msgid ""
"void moneyTransfer(int from, int to, int amount) {\n"
"  bankLock.lock();\n"
"  try {\n"
"    while (accounts[from] < amount)\n"
"      sufficientFunds.await();"
msgstr ""
"void moneyTransfer(int from, int to, int amount) {\n"
"  bankLock.lock();\n"
"  try {\n"
"    while (accounts[from] < amount)\n"
"      sufficientFunds.await();"

#: slides10/src/main/asciidoc/lecture.adoc:583
msgctxt "./slides10/src/main/asciidoc/lecture.adoc:583"
msgid ""
"    accounts[from]-=amount;\n"
"    accounts[to]+=amount;"
msgstr ""
"    accounts[from]-=amount;\n"
"    accounts[to]+=amount;"

#: slides10/src/main/asciidoc/lecture.adoc:591
msgid ""
"    sufficientFunds.signalAll();\n"
"  } finally {\n"
"    bankLock.unlock();\n"
"  }\n"
"}\n"
"----\n"
"== Condition Objects: что происходит?"
msgstr ""
"    sufficientFunds.signalAll();\n"
"  } finally {\n"
"    bankLock.unlock();\n"
"  }\n"
"}\n"
"----\n"
"== Condition Objects: что происходит?"

#: slides10/src/main/asciidoc/lecture.adoc:598
msgid ""
"* `await()` отпускает блокировку и переводит тред в ждущее состояние,\n"
"* `signalAll()` сигнализирует всем ждущим тредам, что что-то поменялось,\n"
"* выход из `await()` _снова захватывает блокировку_.\n"
"* При выходе из `await()` мы вновь проверяем условие, потому что:\n"
"** сигнал мог быть по другому поводу,\n"
"** возможны «спонтанные пробуждения»."
msgstr ""
"* `await()` отпускает блокировку и переводит тред в ждущее состояние,\n"
"* `signalAll()` сигнализирует всем ждущим тредам, что что-то поменялось,\n"
"* выход из `await()` _снова захватывает блокировку_.\n"
"* При выходе из `await()` мы вновь проверяем условие, потому что:\n"
"** сигнал мог быть по другому поводу,\n"
"** возможны «спонтанные пробуждения»."

#: slides10/src/main/asciidoc/lecture.adoc:600
msgid "== Контрольный вопрос"
msgstr "== Контрольный вопрос"

#: slides10/src/main/asciidoc/lecture.adoc:602
msgid ""
"* Чем гарантировано, что при выходе из `await()` мы увидим изменения, "
"сделанные другим тредом?"
msgstr ""
"* Чем гарантировано, что при выходе из `await()` мы увидим изменения, "
"сделанные другим тредом?"

#: slides10/src/main/asciidoc/lecture.adoc:605
msgid ""
"[.fragment]\n"
"* При выходе из `await()` мы снова захватываем блокировку, работает JMM "
"Monitor Lock Rule."
msgstr ""
"[.fragment]\n"
"* При выходе из `await()` мы снова захватываем блокировку, работает JMM "
"Monitor Lock Rule."

#: slides10/src/main/asciidoc/lecture.adoc:613
msgid ""
"== Правильный паттерн ожидания condition\n"
"[source,java]\n"
"----\n"
"while (!okToProceed())\n"
"  condition.await();\n"
"----\n"
"== Intrinsic lock"
msgstr ""
"== Правильный паттерн ожидания condition\n"
"[source,java]\n"
"----\n"
"while (!okToProceed())\n"
"  condition.await();\n"
"----\n"
"== Intrinsic lock"

#: slides10/src/main/asciidoc/lecture.adoc:616
msgid ""
"* Начиная с Java 1.0, каждый объект имеет встроенный (intrinsic) lock.\n"
"* У каждого intrinsic lock есть один condition."
msgstr ""
"* Начиная с Java 1.0, каждый объект имеет встроенный (intrinsic) lock.\n"
"* У каждого intrinsic lock есть один condition."

#: slides10/src/main/asciidoc/lecture.adoc:624
msgid ""
"== То же самое, с помощью intrinsic lock\n"
"[source,java]\n"
"----\n"
"//enter intrinsic lock on *this*\n"
"synchronized void moneyTransfer(int from, int to, int amount) {\n"
"    while (accounts[from] < amount)\n"
"      wait(); //wait on intrinsic object's lock condition"
msgstr ""
"== То же самое, с помощью intrinsic lock\n"
"[source,java]\n"
"----\n"
"//enter intrinsic lock on *this*\n"
"synchronized void moneyTransfer(int from, int to, int amount) {\n"
"    while (accounts[from] < amount)\n"
"      wait(); //wait on intrinsic object's lock condition"

#: slides10/src/main/asciidoc/lecture.adoc:627
msgctxt "./slides10/src/main/asciidoc/lecture.adoc:627"
msgid ""
"    accounts[from]-=amount;\n"
"    accounts[to]+=amount;"
msgstr ""
"    accounts[from]-=amount;\n"
"    accounts[to]+=amount;"

#: slides10/src/main/asciidoc/lecture.adoc:631
msgid ""
"    notifyAll(); //notify all threads waiting on the condition\n"
"}\n"
"----"
msgstr ""
"    notifyAll(); //notify all threads waiting on the condition\n"
"}\n"
"----"

#: slides10/src/main/asciidoc/lecture.adoc:633
msgid "== Synchronized-блок"
msgstr "== Synchronized-блок"

#: slides10/src/main/asciidoc/lecture.adoc:635
msgid "Другая форма использования intrinsic locks:"
msgstr "Другая форма использования intrinsic locks:"

#: slides10/src/main/asciidoc/lecture.adoc:643
msgid ""
"[source,java]\n"
"----\n"
"private Object lock = new Object();\n"
"void moneyTransfer(int from, int to, int amount) {\n"
"  synchronized (lock) {\n"
"    while (accounts[from] < amount)\n"
"      lock.wait();"
msgstr ""
"[source,java]\n"
"----\n"
"private Object lock = new Object();\n"
"void moneyTransfer(int from, int to, int amount) {\n"
"  synchronized (lock) {\n"
"    while (accounts[from] < amount)\n"
"      lock.wait();"

#: slides10/src/main/asciidoc/lecture.adoc:646
msgctxt "./slides10/src/main/asciidoc/lecture.adoc:646"
msgid ""
"    accounts[from]-=amount;\n"
"    accounts[to]+=amount;"
msgstr ""
"    accounts[from]-=amount;\n"
"    accounts[to]+=amount;"

#: slides10/src/main/asciidoc/lecture.adoc:651
msgid ""
"    lock.notifyAll();\n"
"  }\n"
"}\n"
"----"
msgstr ""
"    lock.notifyAll();\n"
"  }\n"
"}\n"
"----"

#: slides10/src/main/asciidoc/lecture.adoc:662
msgid ""
"== Промежуточный итог по intrinsic conditions\n"
"* Нужно работать по строгому паттерну: \n"
"** синхронизация,\n"
"** while-loop wait,\n"
"** нотификация.\n"
"* Нужно держать в уме:\n"
"** по intrinsic lock какого объекта синхронизируемся,\n"
"** по condition какого объекта ждём,\n"
"** треды, ждущие на condition какого объекта нотифицируем (это всё должен "
"быть один объект).\n"
"* В общем, это низкоуровневый и сложный механизм. Его понимание пригодится "
"на собеседованиях, но скорее всего, вам не надо будет им пользоваться."
msgstr ""
"== Промежуточный итог по intrinsic conditions\n"
"* Нужно работать по строгому паттерну: \n"
"** синхронизация,\n"
"** while-loop wait,\n"
"** нотификация.\n"
"* Нужно держать в уме:\n"
"** по intrinsic lock какого объекта синхронизируемся,\n"
"** по condition какого объекта ждём,\n"
"** треды, ждущие на condition какого объекта нотифицируем (это всё должен "
"быть один объект).\n"
"* В общем, это низкоуровневый и сложный механизм. Его понимание пригодится "
"на собеседованиях, но скорее всего, вам не надо будет им пользоваться."

#: slides10/src/main/asciidoc/lecture.adoc:671
msgid ""
"== Теперь нам понятен смысл всех возможных состояний треда\n"
"[graphviz,\"threadstates.png\"]\n"
"----\n"
"digraph G {\n"
"graph [ dpi = 150 ];\n"
"rankdir=\"LR\"\n"
"new -> runnable[label=\"start\"]\n"
"runnable -> terminated[xlabel=\"run\\nmethod exit\"]"
msgstr ""
"== Теперь нам понятен смысл всех возможных состояний треда\n"
"[graphviz,\"threadstates.png\"]\n"
"----\n"
"digraph G {\n"
"graph [ dpi = 150 ];\n"
"rankdir=\"LR\"\n"
"new -> runnable[label=\"start\"]\n"
"runnable -> terminated[xlabel=\"run\\nmethod exit\"]"

#: slides10/src/main/asciidoc/lecture.adoc:674
msgid ""
"runnable -> blocked [label=\"aquiring a lock\"]\n"
"blocked -> runnable [label=\"lock aquired\"]"
msgstr ""
"runnable -> blocked [label=\"aquiring a lock\"]\n"
"blocked -> runnable [label=\"lock aquired\"]"

#: slides10/src/main/asciidoc/lecture.adoc:677
msgid ""
"runnable -> waiting [label=\"waiting for notification\"]\n"
"waiting -> runnable [label=\"notification occured\"]"
msgstr ""
"runnable -> waiting [label=\"waiting for notification\"]\n"
"waiting -> runnable [label=\"notification occured\"]"

#: slides10/src/main/asciidoc/lecture.adoc:680
msgid ""
"runnable -> TW  [label=\"waiting for timeout or notification\"]\n"
"TW -> runnable [xlabel=\"timeout or notification occured\"]"
msgstr ""
"runnable -> TW  [label=\"waiting for timeout or notification\"]\n"
"TW -> runnable [xlabel=\"timeout or notification occured\"]"

#: slides10/src/main/asciidoc/lecture.adoc:682
msgid "TW[label=\"timed\\nwaiting\"]"
msgstr "TW[label=\"timed\\nwaiting\"]"

#: slides10/src/main/asciidoc/lecture.adoc:685
msgid ""
"{rank=same;new;terminated}\n"
"}"
msgstr ""
"{rank=same;new;terminated}\n"
"}"

#: slides10/src/main/asciidoc/lecture.adoc:687
msgid "----"
msgstr "----"

#: slides10/src/main/asciidoc/lecture.adoc:689
msgid "== Промежуточный итог по всему вышесказанному"
msgstr "== Промежуточный итог по всему вышесказанному"

#: slides10/src/main/asciidoc/lecture.adoc:696
msgid ""
"* Где возможно, используйте immutable state: он автоматически "
"потокобезопасен.\n"
"* Используйте volatile переменные или синхронизацию для доступа к mutable "
"state.\n"
"* Удерживайте блокировку во время выполнения операций, которые должны быть "
"атомарными.\n"
"* Повторим ещё раз: *программа с shared mutable state без должной "
"синхронизации -- сломанная программа*.\n"
"* Думайте о потокобезопасности всё время.\n"
"* Понимание JMM помогает"
msgstr ""
"* Где возможно, используйте immutable state: он автоматически "
"потокобезопасен.\n"
"* Используйте volatile переменные или синхронизацию для доступа к mutable "
"state.\n"
"* Удерживайте блокировку во время выполнения операций, которые должны быть "
"атомарными.\n"
"* Повторим ещё раз: *программа с shared mutable state без должной "
"синхронизации -- сломанная программа*.\n"
"* Думайте о потокобезопасности всё время.\n"
"* Понимание JMM помогает"

#: slides10/src/main/asciidoc/lecture.adoc:699
msgid "== Часть 2. Deadlocks"
msgstr "== Часть 2. Deadlocks"

#: slides10/src/main/asciidoc/lecture.adoc:701
msgctxt "./slides10/src/main/asciidoc/lecture.adoc:701"
msgid "image::hydra2.jpg[{image-90-width}]"
msgstr "image::hydra2.jpg[{image-90-width}]"

#: slides10/src/main/asciidoc/lecture.adoc:703
msgid "== Deadlock: простой пример"
msgstr "== Deadlock: простой пример"

#: slides10/src/main/asciidoc/lecture.adoc:709
msgid ""
"[plantuml, deadlock, png]\n"
"----\n"
"@startuml\n"
"skinparam dpi 180\n"
"hide footbox"
msgstr ""
"[plantuml, deadlock, png]\n"
"----\n"
"@startuml\n"
"skinparam dpi 180\n"
"hide footbox"

#: slides10/src/main/asciidoc/lecture.adoc:714
msgid ""
"participant X\n"
"participant Y\n"
"participant LockA\n"
"participant LockB"
msgstr ""
"participant X\n"
"participant Y\n"
"participant LockA\n"
"participant LockB"

#: slides10/src/main/asciidoc/lecture.adoc:718
msgid ""
"X -> LockA: lock()\n"
"activate LockA\n"
"LockA --> X: "
msgstr ""
"X -> LockA: lock()\n"
"activate LockA\n"
"LockA --> X: "

#: slides10/src/main/asciidoc/lecture.adoc:722
msgid ""
"Y -> LockB: lock()\n"
"activate LockB\n"
"LockB --> Y"
msgstr ""
"Y -> LockB: lock()\n"
"activate LockB\n"
"LockB --> Y"

#: slides10/src/main/asciidoc/lecture.adoc:728
msgid ""
"X -> LockB: lock()\n"
"note right\n"
"  будем ждать\n"
"  вечно\n"
"end note"
msgstr ""
"X -> LockB: lock()\n"
"note right\n"
"  будем ждать\n"
"  вечно\n"
"end note"

#: slides10/src/main/asciidoc/lecture.adoc:730
msgid "Y -> LockA: lock()"
msgstr "Y -> LockA: lock()"

#: slides10/src/main/asciidoc/lecture.adoc:733
msgctxt "./slides10/src/main/asciidoc/lecture.adoc:733"
msgid ""
"@enduml\n"
"----"
msgstr ""
"@enduml\n"
"----"

#: slides10/src/main/asciidoc/lecture.adoc:735
msgid "== Перепутанный порядок блокировки"
msgstr "== Перепутанный порядок блокировки"

#: slides10/src/main/asciidoc/lecture.adoc:757
msgid ""
"[source,java]\n"
"----\n"
"class LeftRightDeadlock {\n"
"  private final Object left = new Object();\n"
"  private final Object right = new Object();\n"
"  void leftRight() {\n"
"    synchronized (left) {\n"
"      synchronized (right) {\n"
"        doSomething();\n"
"      }\n"
"    }\n"
"  }\n"
"  void rightLeft() {\n"
"    synchronized (right) {\n"
"      synchronized (left) {\n"
"        doSomethingElse();\n"
"      }\n"
"    }\n"
"  }\n"
"}\n"
"----"
msgstr ""
"[source,java]\n"
"----\n"
"class LeftRightDeadlock {\n"
"  private final Object left = new Object();\n"
"  private final Object right = new Object();\n"
"  void leftRight() {\n"
"    synchronized (left) {\n"
"      synchronized (right) {\n"
"        doSomething();\n"
"      }\n"
"    }\n"
"  }\n"
"  void rightLeft() {\n"
"    synchronized (right) {\n"
"      synchronized (left) {\n"
"        doSomethingElse();\n"
"      }\n"
"    }\n"
"  }\n"
"}\n"
"----"

#: slides10/src/main/asciidoc/lecture.adoc:759
msgid "== Перепутанный (иногда!) порядок блокировки"
msgstr "== Перепутанный (иногда!) порядок блокировки"

#: slides10/src/main/asciidoc/lecture.adoc:776
msgid ""
"[source,java]\n"
"----\n"
"void transferMoney(Account fromAccount, Account toAccount, \n"
"                     int amount) throws InsufficientFundsException {\n"
"  synchronized (fromAccount) {\n"
"    synchronized (toAccount) {\n"
"      if (fromAccount.getBalance() < amount)\n"
"        throw new InsufficientFundsException();\n"
"      else {\n"
"        fromAccount.debit(amount);\n"
"        toAccount.credit(amount);\n"
"      }\n"
"    }\n"
"  }\n"
"}\n"
"----"
msgstr ""
"[source,java]\n"
"----\n"
"void transferMoney(Account fromAccount, Account toAccount, \n"
"                     int amount) throws InsufficientFundsException {\n"
"  synchronized (fromAccount) {\n"
"    synchronized (toAccount) {\n"
"      if (fromAccount.getBalance() < amount)\n"
"        throw new InsufficientFundsException();\n"
"      else {\n"
"        fromAccount.debit(amount);\n"
"        toAccount.credit(amount);\n"
"      }\n"
"    }\n"
"  }\n"
"}\n"
"----"

#: slides10/src/main/asciidoc/lecture.adoc:778
msgid "== Выводы"
msgstr "== Выводы"

#: slides10/src/main/asciidoc/lecture.adoc:782
msgid ""
"* Если процедура захватывает несколько блокировок, возможен deadlock.\n"
"* Во избежание deadlocks нужно следить за тем, чтобы блокировки всегда "
"захватывались в одном и том же порядке. Иногда неочевидно, как это сделать.\n"
"* Если вы захватили блокировку -- закончите с ней как можно быстрее, не "
"вызывайте внешних методов."
msgstr ""
"* Если процедура захватывает несколько блокировок, возможен deadlock.\n"
"* Во избежание deadlocks нужно следить за тем, чтобы блокировки всегда "
"захватывались в одном и том же порядке. Иногда неочевидно, как это сделать.\n"
"* Если вы захватили блокировку -- закончите с ней как можно быстрее, не "
"вызывайте внешних методов."

#: slides10/src/main/asciidoc/lecture.adoc:784
msgid "== Часть 3. Потокобезопасные структуры данных"
msgstr "== Часть 3. Потокобезопасные структуры данных"

#: slides10/src/main/asciidoc/lecture.adoc:786
msgctxt "./slides10/src/main/asciidoc/lecture.adoc:786"
msgid "image::hydra2.jpg[{image-90-width}]"
msgstr "image::hydra2.jpg[{image-90-width}]"

#: slides10/src/main/asciidoc/lecture.adoc:788
msgid "== Неблокирующие алгоритмы"
msgstr "== Неблокирующие алгоритмы"

#: slides10/src/main/asciidoc/lecture.adoc:793
msgid ""
"* Блокировка (через `synchronized` или `ReentrantLock`) решает вопрос "
"координации действий разных тредов с переменной.\n"
"* Но если много тредов конкурируют за блокировку (high lock contention), "
"затраты ресурсов на координацию тредов становятся значительными.\n"
"* Альтернативой являются _неблокирующие алгоритмы_, использующие поддержку "
"специальных атомарных машинных инструкций (compare-and-swap).\n"
"* В Java-библиотеке доступны _классы атомарных переменных_ и "
"_потокобезопасные коллекции_, реализованные в том числе на неблокирующих "
"алгоритмах."
msgstr ""
"* Блокировка (через `synchronized` или `ReentrantLock`) решает вопрос "
"координации действий разных тредов с переменной.\n"
"* Но если много тредов конкурируют за блокировку (high lock contention), "
"затраты ресурсов на координацию тредов становятся значительными.\n"
"* Альтернативой являются _неблокирующие алгоритмы_, использующие поддержку "
"специальных атомарных машинных инструкций (compare-and-swap).\n"
"* В Java-библиотеке доступны _классы атомарных переменных_ и "
"_потокобезопасные коллекции_, реализованные в том числе на неблокирующих "
"алгоритмах."

#: slides10/src/main/asciidoc/lecture.adoc:795
msgid "== Atomics "
msgstr "== Atomics "

#: slides10/src/main/asciidoc/lecture.adoc:802
msgid ""
"* `package java.util.concurrent.atomic`\n"
"** `AtomicBoolean`, `AtomicInteger`, `AtomicLong`, `AtomicReference`.\n"
"** `AtomicIntegerArray`, `AtomicLongArray`, `AtomicReferenceArray`.\n"
"* Могут быть использованы как «улучшенные volatile-переменные», т. к. "
"результат вызова `set(...)` виден другим тредам при вызове `get(...)`\n"
"* Поддерживают атомарные операции."
msgstr ""
"* `package java.util.concurrent.atomic`\n"
"** `AtomicBoolean`, `AtomicInteger`, `AtomicLong`, `AtomicReference`.\n"
"** `AtomicIntegerArray`, `AtomicLongArray`, `AtomicReferenceArray`.\n"
"* Могут быть использованы как «улучшенные volatile-переменные», т. к. "
"результат вызова `set(...)` виден другим тредам при вызове `get(...)`\n"
"* Поддерживают атомарные операции."

#: slides10/src/main/asciidoc/lecture.adoc:804
msgid "== Aтомарные операции в классах атомарных переменных"
msgstr "== Aтомарные операции в классах атомарных переменных"

#: slides10/src/main/asciidoc/lecture.adoc:807
msgid ""
"----\n"
"getAndSet(newValue)    compareAndSet(expect, update) "
msgstr ""
"----\n"
"getAndSet(newValue)    compareAndSet(expect, update) "

#: slides10/src/main/asciidoc/lecture.adoc:809
msgid "incrementAndGet()      decrementAndGet()"
msgstr "incrementAndGet()      decrementAndGet()"

#: slides10/src/main/asciidoc/lecture.adoc:811
msgid "getAndIncrement()      getAndDecrement()"
msgstr "getAndIncrement()      getAndDecrement()"

#: slides10/src/main/asciidoc/lecture.adoc:813
msgid "getAndAdd(delta)       addAndGet(delta)"
msgstr "getAndAdd(delta)       addAndGet(delta)"

#: slides10/src/main/asciidoc/lecture.adoc:816
msgid ""
"getAndUpdate(updateFunction)\n"
"updateAndGet(updateFunction)"
msgstr ""
"getAndUpdate(updateFunction)\n"
"updateAndGet(updateFunction)"

#: slides10/src/main/asciidoc/lecture.adoc:820
msgid ""
"getAndAccumulate(x, accumulatorBiFunction)\n"
"accumulateAndGet(x, accumulatorBiFunction)\n"
"----"
msgstr ""
"getAndAccumulate(x, accumulatorBiFunction)\n"
"accumulateAndGet(x, accumulatorBiFunction)\n"
"----"

#: slides10/src/main/asciidoc/lecture.adoc:823
msgid "== Потокобезопасные коллекции"
msgstr "== Потокобезопасные коллекции"

#: slides10/src/main/asciidoc/lecture.adoc:827
msgid ""
"* В ранних версиях Java можно было «сделать» коллекцию потокобезопасной, "
"обернув в `Collections.synchronizedXXX(...)`. Это сериализовывало любой "
"доступ к внутреннему состоянию коллекции. Из-за поддержки обратной "
"совместимости сейчас так тоже можно, но не нужно.\n"
"* Цена такого решения -- плохой параллелизм: конкуренция за блокировку (lock "
"contention).\n"
"* С версии 5 появились классы, специально разработанные для "
"потокобезопасности, с меньшим количеством блокировок.\n"
"* Их использование является _предпочтительным_."
msgstr ""
"* В ранних версиях Java можно было «сделать» коллекцию потокобезопасной, "
"обернув в `Collections.synchronizedXXX(...)`. Это сериализовывало любой "
"доступ к внутреннему состоянию коллекции. Из-за поддержки обратной "
"совместимости сейчас так тоже можно, но не нужно.\n"
"* Цена такого решения -- плохой параллелизм: конкуренция за блокировку (lock "
"contention).\n"
"* С версии 5 появились классы, специально разработанные для "
"потокобезопасности, с меньшим количеством блокировок.\n"
"* Их использование является _предпочтительным_."
