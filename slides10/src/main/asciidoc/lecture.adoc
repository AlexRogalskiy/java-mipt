= Core Java: Курс лекций. Лекция 10
Иван Пономарёв, КУРС/МФТИ
:revealjs_theme: black
:revealjs_customtheme: white_course.css
:revealjs_slideNumber:
:revealjs_history:
:revealjs_progress:
:encoding: UTF-8
:lang: ru
include::_doc_general_attributes.adoc[]
:doctype: article
:toclevels: 3
:imagesdir: images
:source-highlighter: highlightjs
:highlightjsdir: highlight
:icons: font
:iconfont-remote!:
:iconfont-name: font-awesome-4.7.0/css/font-awesome
:revealjs_mouseWheel: true
:revealjs_center: false
:revealjs_transition: none
:revealjs_width: 1600
:revealjs_height: 900
:stem: latexmath


//== Часть 1. Введение
:!figure-caption:

ponomarev@corchestra.ru

icon:twitter[size=lg] @inponomarev

== Concurrency -- конкурентное выполнение

* Одна программа -- много одновременно выполняющихся тредов (threads)
* Зачем нам вообще Concurrency?

[.fragment]
-- Для перформанса, чтобы побыстрее!

== Где мы можем получить выгоду от concurrency?

* Много CPU-ядер, вычислительная задача хорошо разделяется на подзадачи.
* Подзадачи блокируются на вводе/выводе, можно параллельно ждать других или делать что-то полезное.
* Нужно быстро отреагировать на запрос, а потом дать детальный ответ (пользовательский интерфейс).
* Многопользовательский сервис (каждый запрос в своём треде).


== Где мы НЕ можем получить выгоду от [увеличения] concurrency?

* CPU-bound задача не будет решаться быстрее, если тредов больше, чем ядер.
* Задача плохо параллелизуется (упирается в неразделяемый ресурс).
* Нас ограничивает закон Амдала.

== Закон Амдала (Amdahl's law)

* &alpha; -- доля вычислений, которая должна выполняться последовательно,
* _N_ -- число параллельных потоков выполнения,
* _S_ -- полученное ускорение (speedup).

[stem] 
++++
\Huge
S = \frac{1}{\alpha+\frac{1-\alpha}{N}} = \frac{N}{1+\alpha(N-1)} \leq \frac{1}{\alpha}
++++

Вывод: если разделяемая работа составляет 80%, вы не получите более чем пятикратное увеличение производительности за счёт параллелизации.

== Закон Амдала: поведение
// https://shipilev.net/talks/jpoint-April2017-perf-keynote.pdf

image::amdahl.png[{image-80-width}]

== На самом деле, всё ещё хуже! 

* Uiversal Scalability Law -- эмпирическое обобщение закона Амдала
* &beta; -- параметр, определяющий cohesion (межпоточную координацию)
* хорошо ложится на эмпирические данные

[stem] 
++++
\Huge
S = \frac{N}{1+\alpha(N-1) + \beta N (N-1)}
++++
== USL: поведение

image::usl.png[{image-80-width}]

== Промежуточный вывод

* Перед тем, как встать на скользкую тропу многопоточного программирования, подумайте: 
** нужно ли это для решения задачи?
** насколько многопоточным должно быть решение?
* Вас предупредили.

image::hydra1.jpg[{image-40-width}]

//https://www.ancient.eu/img/r/p/750x750/3359.jpg?v=1539676109


== Часть 1. Зачем нужна и как достигается синхронизация

image::hydra2.jpg[{image-90-width}]

[[first_example]]
== Многопоточность в Java (с самой первой версии!)

[plantuml, runthr, png]
----
@startuml

skinparam dpi 150 

interface Runnable {
  void run()
}

class Thread {
  void start()
  void join([long millis]) throws InterruptedException
  void interrupt()
  Thread.state getState()
}


Runnable <|- Thread

@enduml
----

[source,java]
----
class CalcSquare extends Thread {
    final int argument;
    int result;
    CalcSquare(int argument) {
        this.argument = argument;
    }
    @Override
    public void run() {
        //«сложные» вычисления
        result = argument * argument;
    }
}
----

== Запуск параллельных вычислений через Thread API

* NB: в современной реальности вы не будете пользоваться Thread API

[source,java]
----
CalcSquare t1 = new CalcSquare(2);
CalcSquare t2 = new CalcSquare(3);
t1.start();
t2.start();
t1.join();
t2.join();
System.out.printf("%d, %d%n", t1.result, t2.result);
//otput: 4, 6
----


== Проблемы с shared state

[cols="50a,.^50a"]
|===
|image::hydraheads.jpg[]
|
* Race condition
* Stale values
* Reordering
|===

== Race condition

[source,java]
----
class DumbCounter {
  int count;
  void increment(){
    count++;
  }
}

DumbCounter c1 = new DumbCounter();
IntStream.range(0, 1000000).forEach(i->c1.increment());

DumbCounter c2 = new DumbCounter();
IntStream.range(0, 1000000).parallel().forEach(i->c2.increment());

System.out.printf("%d, %d%n", c1.count, c2.count);

//1000000,??????
----


== Stale values

[source,java]
----
class DumbWayToFallAsleep implements Runnable {
  private boolean asleep;
  
  public void setAsleep(boolean asleep){
    this.asleep = asleep;
  }

  @Override
  public void run() {
    while (!asleep){
      //countSomeSheep
      //УСНЁМ ЛИ МЫ?
    }
  }
}
----


== Reordering

[source,java]
----
class PossibleReordering {
  static int x = 0, y = 0, a = 0, b = 0;
  public static void main(String... args) 
                throws InterruptedException {
    //другой способ запуска треда (тоже не будете пользоваться)
    Thread one = new Thread(() -> {
        a = 1; x = b;
    });
    Thread two = new Thread(() -> {
        b = 1; y = a;
    });
    one.start(); two.start();
    one.join();  two.join();
    System.out.printf("%d,%d", x, y);
    //??,??
  }
}
----


== Промежуточные выводы

* Из-за reordering и других низкоуровневых особенностей _нельзя_ рассуждать о результате работы одного треда с точки зрения другого треда как о промежуточном результате выполнения исходного кода. 

* Все проблемы с параллельными вычислениями связаны с shared state.

* Показанные здесь проблемы проявляются недетерминированно.

* Любая программа с доступом к shared state без должной синхронизации -- _сломана_, даже если «вчера это работало на моей машине».

== Модель памяти

[source,java]
----
int aVariable = 42; 
----

* Модель памяти (Java Memory Model, JMM) -- спецификация языка и виртуальной машины, отвечающая на вопрос: «при каких условиях поток, читающий переменную `aVariable`, увидит значение 42?»

== Happens-before

* JMM определяет частичный порядок на всех действиях в Java-программе, называемый _happens-before_.

* Отношение _happens-before_ транзитивно: stem:[A \prec B \wedge B \prec C \Rightarrow A \prec C]

* Чтобы действие B гарантированно видело результат работы действия A, достаточно, чтобы stem:[A \prec B].

== Program order rule

* В рамках одного треда все действия _happens-before_ в порядке их определения в исходном коде программы. 

* Иными словами, однопоточные программы выполняются без сюрпризов.

== Thread start & thread termination rule

* Вызов `threadA.start()` _happens-before_ всех операций в потоке `threadA`.
* Любая операция в потоке `threadA` _happens-before_ обнаружения другим потоком завершения `threadA`, либо путём выхода из `threadA.join()`, либо путём проверки `threadA.isAlive() == false`.
* Благодаря этому правилу, <<first_example,наш самый первый пример>> на параллелизацию работает корректно.


== Ключевое слово volatile

* Переменные классов могут быть определены с ключевым словом `volatile`.

* *Запись в `volatile`-переменную _happens-before_ чтения из этой переменной.*

* Это автоматом делает видимыми изменения в других переменных. Полагаться на это не рекомендуется: это работает, но делает код хрупким. В процессе рефакторинга можно поменять порядок доступа к переменным и тем самым незаметно поломать программу. 

== Чиним stale value при помощи volatile

[source,java]
----
class NotSoDumbWayToFallAsleep implements Runnable {
  private volatile boolean asleep;
        
  public void setAsleep(boolean asleep){
    this.asleep = asleep;
  }

  @Override
  public void run() {
    while (!asleep){
      //countSomeSheep
      //...
    }
  }
}
----

== final-поля

* Если объект правильно опубликован, т. е.  _ссылка на него не утекает во время выполнения конструктора_ --  `final`-поля объекта доступны всем тредам без синхронизации.

* Лучший способ борьбы с проблемами mutable state -- использовать immutable state где только возможно.

== Неатомарные операции: final не годится, volatile не спасёт

[cols="50a,50a"]
|===
|
[source,java]
----
class DumbCounter {
  int count;
  void increment(){
    count++;
  }
}
----
(Мы можем объявить `count` как volatile, но ситуация не улучшится.)

|[source,java]
----
void dumbMoneyTransfer(
  int from, int to, int amount){
    
    accounts[from]-=amount;
    accounts[to]+=amount;
}
----

(Кстати, `volatile array` -- не массив `volatile`-элементов. И вообще в Java просто так массив `volatile`-элементов не создать.)
|===
 

== Несинхронизированное выполнение
[plantuml, nonsync, png]
----
@startuml
skinparam dpi 180
participant Client1
participant Client2
participant Bank

Client1 -> Bank: transfer
activate Bank

Client2 -> Bank: transfer
Bank --> Client1 


Bank --> Client2
deactivate Bank

@enduml
----

== Синхронизированное выполнение
[plantuml, sync, png]
----
@startuml
skinparam dpi 180
participant Client1
participant Client2
participant Lock
participant Bank


Client1 -> Lock: lock
activate Lock
Lock --> Client1
deactivate Lock

Client1 -> Bank: transfer
activate Bank

Client2 -> Lock: lock
activate Lock

Bank --> Client1 
deactivate Bank

Client1 -> Lock: unlock
Lock --> Client1
Lock --> Client2
deactivate Lock

Client2 -> Bank: transfer
activate Bank
Bank --> Client2
deactivate Bank

@enduml
----


== Блокировки

[source,java]
----
//Reentrant так называется потому,
//что одному и тому же треду позволено входить повторно
private ReentrantLock bankLock = new ReentrantLock(); 

void moneyTransfer(int from, int to, int amount) {
  bankLock.lock();
  try {
    accounts[from]-=amount;
    accounts[to]+=amount;
  } finally {
    bankLock.unlock();
  }
}
----
[.fragment]
Если вы задались вопросом: «где гарантии, что после выхода из блокировки тред увидит результат работы предыдущего треда?» -- поздравляю, вы начали что-то понимать.

== JMM Monitor Lock Rule

* Разблокировка (unlocking) _happens-before_ другой блокировки (locking) того же самого «замка» (lock).
* Поэтому защищённые блокировкой переменные объявлять как `volatile` уже не нужно.

== В чём проблема здесь?

[source,java]
----
while (accounts[from] < amount) {
    //wait ....
}

bankLock.lock();
try {
  //transfer funds ...
} finally {
  bankLock.unlock();
}
----
[.fragment]
Доступ к `accounts[from]` не синхронизирован, но даже если бы он был синхронизирован, кто-то смог бы уменьшить количество денег до вхождения в блок transfer funds.

== В чём пробема здесь?

[source,java]
----
bankLock.lock();
try {
  while (accounts[from] < amount) {
    //wait ....
  }
  //transfer funds ...
} finally {
  bankLock.unlock();
}
----
[.fragment]
Мы заблокировали `bankLock` и ждём, пока кто-то закинет денег. Но никто никогда не сможет это сделать, т. к. `bankLock` занят нами.

== Condition Objects

[source,java]
----
private ReentrantLock bankLock = new ReentrantLock(); 
private Condition sufficientFunds = bankLock.newCondition();

void moneyTransfer(int from, int to, int amount) {
  bankLock.lock();
  try {
    while (accounts[from] < amount)
      sufficientFunds.await();
      
    accounts[from]-=amount;
    accounts[to]+=amount;
    
    sufficientFunds.signalAll();
  } finally {
    bankLock.unlock();
  }
}
----
== Condition Objects: что происходит?

* `await()` отпускает блокировку и переводит тред в ждущее состояние,
* `signalAll()` сигнализирует всем ждущим тредам, что что-то поменялось,
* выход из `await()` _снова захватывает блокировку_.
* При выходе из `await()` мы вновь проверяем условие, потому что:
** сигнал мог быть по другому поводу,
** возможны «спонтанные пробуждения».

== Контрольный вопрос

* Чем гарантировано, что при выходе из `await()` мы увидим изменения, сделанные другим тредом?

[.fragment]
* При выходе из `await()` мы снова захватываем блокировку, работает JMM Monitor Lock Rule.

== Правильный паттерн ожидания condition
[source,java]
----
while (!okToProceed())
  condition.await();
----
== Intrinsic lock

* Начиная с Java 1.0, каждый объект имеет встроенный (intrinsic) lock.
* У каждого intrinsic lock есть один condition.

== То же самое, с помощью intrinsic lock
[source,java]
----
//enter intrinsic lock on *this*
synchronized void moneyTransfer(int from, int to, int amount) {
    while (accounts[from] < amount)
      wait(); //wait on intrinsic object's lock condition
      
    accounts[from]-=amount;
    accounts[to]+=amount;
    
    notifyAll(); //notify all threads waiting on the condition
}
----

== Synchronized-блок

Другая форма использования intrinsic locks:

[source,java]
----
private Object lock = new Object();
void moneyTransfer(int from, int to, int amount) {
  synchronized (lock) {
    while (accounts[from] < amount)
      lock.wait();
      
    accounts[from]-=amount;
    accounts[to]+=amount;
    
    lock.notifyAll();
  }
}
----

== Промежуточный итог по intrinsic conditions
* Нужно работать по строгому паттерну: 
** синхронизация,
** while-loop wait,
** нотификация.
* Нужно держать в уме:
** по intrinsic lock какого объекта синхронизируемся,
** по condition какого объекта ждём,
** треды, ждущие на condition какого объекта нотифицируем (это всё должен быть один объект).
* В общем, это низкоуровневый и сложный механизм. Его понимание пригодится на собеседованиях, но скорее всего, вам не надо будет им пользоваться.

== Теперь нам понятен смысл всех возможных состояний треда
[graphviz,"threadstates.png"]
----
digraph G {
graph [ dpi = 150 ];
rankdir="LR"
new -> runnable[label="start"]
runnable -> terminated[xlabel="run\nmethod exit"]

runnable -> blocked [label="aquiring a lock"]
blocked -> runnable [label="lock aquired"]

runnable -> waiting [label="waiting for notification"]
waiting -> runnable [label="notification occured"]

runnable -> TW  [label="waiting for timeout or notification"]
TW -> runnable [xlabel="timeout or notification occured"]

TW[label="timed\nwaiting"]

{rank=same;new;terminated}
}

----

== Промежуточный итог по всему вышесказанному

* Где возможно, используйте immutable state: он автоматически потокобезопасен.
* Используйте volatile переменные или синхронизацию для доступа к mutable state.
* Удерживайте блокировку во время выполнения операций, которые должны быть атомарными.
* Повторим ещё раз: *программа с shared mutable state без должной синхронизации -- сломанная программа*.
* Думайте о потокобезопасности всё время.
* Понимание JMM помогает


== Часть 2. Deadlocks

image::hydra2.jpg[{image-90-width}]

== Deadlock: простой пример

[plantuml, deadlock, png]
----
@startuml
skinparam dpi 180
hide footbox

participant X
participant Y
participant LockA
participant LockB

X -> LockA: lock()
activate LockA
LockA --> X: 

Y -> LockB: lock()
activate LockB
LockB --> Y

X -> LockB: lock()
note right
  будем ждать
  вечно
end note

Y -> LockA: lock()

@enduml
----

== Перепутанный порядок блокировки

[source,java]
----
class LeftRightDeadlock {
  private final Object left = new Object();
  private final Object right = new Object();
  void leftRight() {
    synchronized (left) {
      syncrhonized (right) {
        doSomething();
      }
    }
  }
  void rightLeft() {
    synchronized (right) {
      syncrhonized (left) {
        doSomethingElse();
      }
    }
  }
}
----

== Перепутанный (иногда!) порядок блокировки

[source,java]
----
void transferMoney(Account fromAccount, Account toAccount, 
                     int amount) throws InsufficientFundsException {
  synchronized (fromAccount) {
    synchronized (toAccount) {
      if (fromAccount.getBalance() < amount)
        throw new InsufficientFundsException();
      else {
        fromAccount.debit(amount);
        toAccount.credit(amount);
      }
    }
  }
}
----

== Выводы

* Если процедура захватывает несколько блокировок, возможен deadlock.
* Во избежание deadlocks нужно следить за тем, чтобы блокировки всегда захватывались в одном и том же порядке. Иногда неочевидно, как это сделать.
* Если вы захватили блокировку -- закончите с ней как можно быстрее, не вызывайте внешних методов.

== Часть 3. Потокобезопасные структуры данных

image::hydra2.jpg[{image-90-width}]

== Неблокирующие алгоритмы

* Блокировка (через `synchronized` или `ReentrantLock`) решает вопрос координации действий разных тредов с переменной.
* Но если много тредов конкурируют за блокировку (high lock contention), затраты ресурсов на координацию тредов становятся значительными.
* Альтернативой являются _неблокирующие алгоритмы_, использующие поддержку специальных атомарных машинных инструкций (compare-and-swap).
* В Java-библиотеке доступны _классы атомарных переменных_ и _потокобезопасные коллекции_, реализованные в том числе на неблокирующих алгоритмах.

== Atomics 


* `package java.util.concurrent.atomic`
** `AtomicBoolean`, `AtomicInteger`, `AtomicLong`, `AtomicReference`.
** `AtomicIntegerArray`, `AtomicLongArray`, `AtomicReferenceArray`.
* Могут быть использованы как «улучшенные volatile-переменные», т. к. результат вызова `set(...)` виден другим тредам при вызове `get(...)`
* Поддерживают атомарные операции.

== Aтомарные операции в классах атомарных переменных

----
getAndSet(newValue)    compareAndSet(expect, update) 

incrementAndGet()      decrementAndGet()

getAndIncrement()      getAndDecrement()

getAndAdd(delta)       addAndGet(delta)

getAndUpdate(updateFunction)
updateAndGet(updateFunction)

getAndAccumulate(x, accumulatorBiFunction)
accumulateAndGet(x, accumulatorBiFunction)
----

== Потокобезопасные коллекции

* В ранних версиях Java можно было «сделать» коллекцию потокобезопасной, обернув в `Collections.synchronizedXXX(...)`. Это сериализовывало любой доступ к внутреннему состоянию коллекции. Из-за поддержки обратной совместимости сейчас так тоже можно, но не нужно.
* Цена такого решения -- плохой параллелизм: конкуренция за блокировку (lock contention).
* С версии 5 появились классы, специально разработанные для потокобезопасности, с меньшим количеством блокировок.
* Их использование является _предпочтительным_.

== CopyOnWriteArrayList и CopyOnWriteArraySet
[source,java]
----
class CopyOnWriteArrayList<E> implements List<E>
class CopyOnWriteArraySet<E> extends AbstractSet<E>
----

* Структуры данных на основе массива.
* Пересоздают всё заново при каждой модификации.
* Это дорого, зато все читающие итераторы стабильны.
* Хороши, когда на одну операцию записи приходится много операций чтения.

== ConcurrentLinkedQueue

[source,java]
----
class ConcurrentLinkedQueue<E> extends AbstractQueue<E>
        implements Queue<E>
----

* Основан на неблокирующем алгоритме (CAS-операции)
* `poll()` вернёт `null`, если очередь пуста

== Блокирующие очереди: средство реализации producer-consumer pattern

[plantuml, blockingqueue, png]
----
@startuml

skinparam dpi 150 

interface BlockingQueue<E> {
  void put(E e) throws InterruptedException;
  E take() throws InterruptedException;
}

class ArrayBlockingQueue<E>
class LinkedBlockingDeque<E>
class PriorityBlockingQueue<E>
class SynchronousQueue<E>

BlockingQueue <|.. ArrayBlockingQueue
BlockingQueue <|.. LinkedBlockingDeque
BlockingQueue <|.. PriorityBlockingQueue
BlockingQueue <|.. SynchronousQueue
@enduml
----

* Могут быть ограничены по размеру (capacity constrained).
* Методы `put()` и `take()` ждут, пока не появится возможность положить или взять элемент.
* `PriorityBlockingQueue` не лимитируется по capacity.
* `SynchronousQueue` не имеет capacity вовсе, передаёт элементы обрабатывающим тредам напрямую. 

== ConcurrentHashMap

[source,java]
----
class ConcurrentHashMap<K,V> extends AbstractMap<K,V>
    implements ConcurrentMap<K,V>
----
* Замена `HashMap` при разделённом доступе к данным.
* Не блокируется при чтении и редко блокируется при записи.
* Не позволяет использовать `null` в качестве ключа или значения.
* Полезные методы атомарны:
** `putIfAbsent(key, value)`
** `remove(key, value)`
** `replace(key, oldValue, newValue)`

== ConcurrentSkipListMap

[source,java]
----
class ConcurrentSkipListMap<K,V> extends AbstractMap<K,V>
    implements ConcurrentNavigableMap<K,V>
----
* Замена `TreeMap` при разделённом доступе к данным.
* Не позволяет использовать `null` в качестве ключа или значения.
* Имеет атомарные методы.

== Часть 4. Executor Framework

image::hydra2.jpg[{image-90-width}]

== Executor Framework

* Тред -- дорогой ресурс, поэтому мы хотим:
** ограничивать количество наших тредов, чтобы не устроить Out of Memory,
** переиспользовать имеющиеся треды, подавая им новые задачи после завершения старых,
** но если какой-то тред «вылетел» -- автоматически создавать новый.
* В стандартной библиотеке для этого есть Thread Pools, не надо ничего делать самостоятельно.
* Никто не использует Thread API напрямую.

== Executor Framework

[source,java]
----
//Абстракция вычислительной задачи, возвращающей результат
public interface Callable<V> {
  V call() throws Exception;
}

//Абстракция «менджера тредов»
public interface ExecutorService {
  <T> Future<T> submit(Callable<T> task);
  /*...есть и много другого, речь впереди...*/
}
----

== Future

[source,java]
----
//Абстракция результата "in progress", который можно ждать, 
//а можно и отменить
public interface Future<V> {
  V get() throws InterruptedException, ExecutionException;
  V get(long timeout, TimeUnit unit)
    throws InterruptedException, ExecutionException, TimeoutException;
  boolean cancel(boolean mayInterruptIfRunning);
  boolean isCancelled();
}
----

== Task, Executor, Future

[plantuml, taskexecfuture, png]
----
@startuml
skinparam dpi 180
hide footbox

participant Client
participant Task
participant Executor
participant Future

Client -> Task: new()
Task --> Client: task

Client -> Executor: submit(task)
Executor -> Future: new(task)
Future --> Executor: Future
Executor --> Client: Future 

Executor -> Future: run()
note right
  в отдельном потоке
  выполнения
end note

Future -> Task: call()
activate Task

Client -> Future: get()
activate Future
Task --> Future: result
deactivate Task
Future --> Client: result
deactivate Future

@enduml
----

== Как создать ExecutorService?

[source,java]
----
public class  Executors {
  //фиксированный размер пула
  public static ExecutorService newFixedThreadPool(int nThreads)
  public static ExecutorService newSingleThreadExecutor()
  //пул растёт по необходимости, держит неактивный тред 60 секунд
  public static ExecutorService newCachedThreadPool()
  //позволяет выполнять задачи с задержкой или периодичностью
  public static 
    ScheduledExecutorService newScheduledThreadPool(int corePoolSize)
  ...
}
----

== Обработка задач «пачками»
[source,java]
----
//Запускаем и ждём, пока все выполнятся
//List<Future<T>>, а не List<T>, т. к. возможны исключения
<T> List<Future<T>> invokeAll(
    Collection<? extends Callable<T>> tasks)
        throws InterruptedException

//Запускаем, возвращаем первый успешный результат, 
//отменяем остальные
<T> T invokeAny(Collection<? extends Callable<T>> tasks)
        throws InterruptedException, ExecutionException;
----

== Отмена задач и «прекращение облуживания»

[source,java]
----
//отменить задачу, если она ещё не начала выполняться
future.cancel(false)

//Запретить приём новых задач
executorService.shutdown();
//Подождать, пока принятые задачи завершатся
if (!service.awaitTermination(10, TimeUnit.SECONDS)){
    //Прервать выполнение задач
    service.shutdownNow();
}
----

== Прерывание задач

* В ранних версиях Java существовали (ныне deprecated) методы принудительной остановки и приостановки/возобновления тредов, но _это оказалось плохой идеей:_
** нет гарантий, что тред не остановится посередине атомарной операции.
** приостановка может на неопределённое время "завесить" блокировку
* В итоге, имеется _кооперативный_ механизм прерывания.

== Прерывание тредов

* `ExecutorService.shutdownNow()` вызывает метод `Thread.interrupt()` на потоках выполнения.
* метод `Thread.isInterrupted()` возвращает статус прерывания треда.
* *JMM Interruption Rule*: вызов метода `interrupt()` внешним потоком _happens-before_ прерываемый поток узнаёт о том, что он прерван.

== Кооперативный механизм прерывания

* Если вычисления в цикле, тред обязан периодически проверять статус `Thread.currentThread().isInterrupted()` и, если флаг выставлен, _записав в лог факт прерывания_, выходить из метода.

* На ждущих методах может быть выброшен `InterruptedException`. Что с ним делать?

== Что делать с `InterruptedException`

* Если контекст позволяет, его всегда следует пробрасывать выше (декларируя в `throws`).

* Если выше пробрасывать нельзя (например, мы находимся в методе `run` интерфейса `Runnable`), то: 

[source,java]
----
} catch (InterruptedException e) {
    //записываем факт прерывания в лог ...
    ...
    //восстанавливаем interrupted-статус
    Thread.currentThread().interrupt();
    //выходим из прерванной процедуры
    return;
}
----
* Просто так "проглатывать" `InterruptedException` *ни в коем случае нельзя*!
* Рекомендуется записывать факт прерывания в лог, для прозрачности отладки.

== CompletableFuture

* Появились в Java 8, расширяют `Future`.
* Позволяют явно задать результат (отсюда 'Completable') и собрать цепочку асинхронных вычислений.
* Могут быть использованы так: 

[source,java]
----
CompletableFuture<Integer> f = new CompletableFuture<>();
executor.execute(() -> {
  int n = workHard(arg);
  f.complete(n); });
  
executor.execute(() -> {
  int n = workSmart(arg);
  f.complete(n); });

executor.execute(() -> {
  Throwable t = ...;
  f.completeExceptionally(t); });
----

== Композиция CompletableFuture с действием

[cols="20a,20a,60a"]
|===
|*Method*            |*Parameter*            |*Description*
|`thenApply`         |T->U                   |Apply a function to the result.
|`thenAccept`        |T->void                |Like `thenApply`, but with `void` result.
|`thenCompose`       |T->CompletableFuture<U>|Invoke the function on the result and execute the returned future.
|`handle`            |(T, Throwable) -> U    |Process the result or error and yield a new result.
|`whenComplete`      |(T, Throwable) -> void |Like `handle`, but with `void` result.
|===


== Композиция CompletableFuture с действием

[cols="20a,20a,60a"]
|===
|*Method*            |*Parameter*            |*Description*
|`completeOnTimeout` |T, long, TimeUnit      |Compute a result from the error.
|`orTimeout`         |long, TimeUnit         |Yield the given value as the result in case of timeout.
|`thenRun`           |Runnable               |Execute the `Runnable` with void result.
|===

== Композиция нескольких CompletableFuture

[cols="20a,20a,60a"]
|===
|*Method*            |*Parameter*            |*Description*
|`thenCombine`       |ComletableFuture<U>, +
                      (T, U)->V              |Execute both and combine the results with the given function.
|`thenAcceptBoth`    |ComletableFuture<U>, +
                      (T, U)->void           |Like `thenCombine`, but with `void` result.
|`runAfterBoth`      |CompletableFuture<?>, +
                      Runnable               |Execute the runnable after both complete.
|===

== Композиция нескольких CompletableFuture
[cols="20a,20a,60a"]
|===
|*Method*            |*Parameter*            |*Description*
|`applyToEither`     |CompletableFuture<T>, +
                      T->V                   |When a result is available from one or the other, pass it to the given function.
|`acceptEither`      |CompletableFuture<T>, +
                      T->void                |Like `applyToEither`, but with `void` result.
|`runAfterEither`    |CompletableFuture<?>, +
                      Runnable               |Execute the runnable after one or the other completes.
|`static allOf`      |CompletableFuture<?>...|Complete with `void` result after all given futeres complete.
|`static anyOf`      |CompletableFuture<?>...|Complete after any of the given futures completes, with the same result cast to `Object`.
|===

== Если этого показалось мало...
* Каждый из этих методов имеет вариант с постфиксом `Async` (например, `thenApplyAsync`), позволяющий выполнить дополнительное действие в другом треде заданного Executor-a.

== Мы только прошлись по основам

[cols="30a,70a"]
|===
|image::jcip.jpg[]| 
* *Brian Goetz et al.*, Java Concurrency in Practice.
* Вышла в 2006-м году, в эпоху Java 5.0.
* Новых изданий не выходило.
* На русский язык не переведена.
* Всё ещё самое полное руководство по разным аспектам многопоточного программирования на Java.
|===